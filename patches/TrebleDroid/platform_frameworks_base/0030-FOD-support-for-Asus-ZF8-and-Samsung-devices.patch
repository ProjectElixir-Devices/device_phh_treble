From 2d178458a201b2396d466ee73eec50c213781a4e Mon Sep 17 00:00:00 2001
From: Pierre-Hugues Husson <phh@phh.me>
Date: Sun, 18 Dec 2022 18:20:40 -0500
Subject: [PATCH 30/36] FOD support for Asus ZF8 and Samsung devices

Thanks Asus for providing a free device to make this support
And thanks @davigamer987 for donating enough to get a Samsung FOD device
to make this
---
 packages/SystemUI/Android.bp                  |   1 +
 packages/SystemUI/res/values/config.xml       |   2 +-
 .../biometrics/UdfpsControllerOverlay.kt      |   6 +-
 .../biometrics/UdfpsControllerOverlay.kt.orig | 520 ++++++++++++++++++
 .../android/systemui/biometrics/UdfpsView.kt  | 137 +++++
 services/core/Android.bp                      |   7 +-
 .../server/biometrics/AuthService.java        | 238 +++++++-
 7 files changed, 906 insertions(+), 5 deletions(-)
 create mode 100644 packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt.orig

diff --git a/packages/SystemUI/Android.bp b/packages/SystemUI/Android.bp
index f156a2c5..71c3a792 100644
--- a/packages/SystemUI/Android.bp
+++ b/packages/SystemUI/Android.bp
@@ -177,6 +177,7 @@ android_library {
         "lottie",
         "LowLightDreamLib",
         "motion_tool_lib",
+        "vendor.goodix.hardware.biometrics.fingerprint-V2.1-java",
         "bcsmartspace-google",
         "faceunlock_framework",
         "vendor.lineage.powershare-V1.0-java",
diff --git a/packages/SystemUI/res/values/config.xml b/packages/SystemUI/res/values/config.xml
index c8f86563..580a530b 100644
--- a/packages/SystemUI/res/values/config.xml
+++ b/packages/SystemUI/res/values/config.xml
@@ -585,7 +585,7 @@
 
     <!-- The radius of the enrollment progress bar, in dp -->
     <integer name="config_udfpsEnrollProgressBar" translatable="false">
-        70
+        50
     </integer>
 
     <!-- The time (in ms) needed to trigger the lock icon view's long-press affordance -->
diff --git a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt
index 6a03531d..6644f2e5 100644
--- a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt
+++ b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt
@@ -122,7 +122,8 @@ class UdfpsControllerOverlay @JvmOverloads constructor(
         gravity = android.view.Gravity.TOP or android.view.Gravity.LEFT
         layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS
         flags = (Utils.FINGERPRINT_OVERLAY_LAYOUT_PARAM_FLAGS or
-                WindowManager.LayoutParams.FLAG_SPLIT_TOUCH)
+                WindowManager.LayoutParams.FLAG_SPLIT_TOUCH) or
+		WindowManager.LayoutParams.FLAG_DIM_BEHIND
         if (frameworkDimming) {
             flags = flags or WindowManager.LayoutParams.FLAG_DIM_BEHIND
         }
@@ -201,6 +202,9 @@ class UdfpsControllerOverlay @JvmOverloads constructor(
                     windowManager.addView(this, coreLayoutParams.updateDimensions(animation))
                     sensorRect = sensorBounds
                     touchExplorationEnabled = accessibilityManager.isTouchExplorationEnabled
+                    dimUpdate = {
+                        windowManager.updateViewLayout(this, coreLayoutParams.updateDimensions(animation).apply { dimAmount = it })
+                    }
                     overlayTouchListener = TouchExplorationStateChangeListener {
                         if (accessibilityManager.isTouchExplorationEnabled) {
                             setOnHoverListener { v, event -> onTouch(v, event, true) }
diff --git a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt.orig b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt.orig
new file mode 100644
index 00000000..6a03531d
--- /dev/null
+++ b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsControllerOverlay.kt.orig
@@ -0,0 +1,520 @@
+/*
+ * Copyright (C) 2021 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.android.systemui.biometrics
+
+import android.annotation.SuppressLint
+import android.annotation.UiThread
+import android.content.Context
+import android.graphics.PixelFormat
+import android.graphics.Rect
+import android.hardware.biometrics.BiometricOverlayConstants.REASON_AUTH_BP
+import android.hardware.biometrics.BiometricOverlayConstants.REASON_AUTH_KEYGUARD
+import android.hardware.biometrics.BiometricOverlayConstants.REASON_AUTH_OTHER
+import android.hardware.biometrics.BiometricOverlayConstants.REASON_AUTH_SETTINGS
+import android.hardware.biometrics.BiometricOverlayConstants.REASON_ENROLL_ENROLLING
+import android.hardware.biometrics.BiometricOverlayConstants.REASON_ENROLL_FIND_SENSOR
+import android.hardware.biometrics.BiometricOverlayConstants.ShowReason
+import android.hardware.fingerprint.FingerprintManager
+import android.hardware.fingerprint.IUdfpsOverlayControllerCallback
+import android.os.Build
+import android.os.RemoteException
+import android.provider.Settings
+import android.util.Log
+import android.util.RotationUtils
+import android.view.LayoutInflater
+import android.view.MotionEvent
+import android.view.Surface
+import android.view.View
+import android.view.WindowManager
+import android.view.accessibility.AccessibilityManager
+import android.view.accessibility.AccessibilityManager.TouchExplorationStateChangeListener
+import androidx.annotation.LayoutRes
+import androidx.annotation.VisibleForTesting
+import com.android.keyguard.KeyguardUpdateMonitor
+import com.android.systemui.R
+import com.android.systemui.animation.ActivityLaunchAnimator
+import com.android.systemui.dump.DumpManager
+import com.android.systemui.flags.FeatureFlags
+import com.android.systemui.flags.Flags
+import com.android.systemui.keyguard.domain.interactor.AlternateBouncerInteractor
+import com.android.systemui.keyguard.domain.interactor.PrimaryBouncerInteractor
+import com.android.systemui.plugins.statusbar.StatusBarStateController
+import com.android.systemui.shade.ShadeExpansionStateManager
+import com.android.systemui.statusbar.LockscreenShadeTransitionController
+import com.android.systemui.statusbar.phone.StatusBarKeyguardViewManager
+import com.android.systemui.statusbar.phone.SystemUIDialogManager
+import com.android.systemui.statusbar.phone.UnlockedScreenOffAnimationController
+import com.android.systemui.statusbar.policy.ConfigurationController
+import com.android.systemui.statusbar.policy.KeyguardStateController
+import com.android.systemui.util.settings.SecureSettings
+
+private const val TAG = "UdfpsControllerOverlay"
+
+@VisibleForTesting
+const val SETTING_REMOVE_ENROLLMENT_UI = "udfps_overlay_remove_enrollment_ui"
+
+/**
+ * Keeps track of the overlay state and UI resources associated with a single FingerprintService
+ * request. This state can persist across configuration changes via the [show] and [hide]
+ * methods.
+ */
+@UiThread
+class UdfpsControllerOverlay @JvmOverloads constructor(
+        private val context: Context,
+        fingerprintManager: FingerprintManager,
+        private val inflater: LayoutInflater,
+        private val windowManager: WindowManager,
+        private val accessibilityManager: AccessibilityManager,
+        private val statusBarStateController: StatusBarStateController,
+        private val shadeExpansionStateManager: ShadeExpansionStateManager,
+        private val statusBarKeyguardViewManager: StatusBarKeyguardViewManager,
+        private val keyguardUpdateMonitor: KeyguardUpdateMonitor,
+        private val dialogManager: SystemUIDialogManager,
+        private val dumpManager: DumpManager,
+        private val transitionController: LockscreenShadeTransitionController,
+        private val configurationController: ConfigurationController,
+        private val keyguardStateController: KeyguardStateController,
+        private val unlockedScreenOffAnimationController: UnlockedScreenOffAnimationController,
+        private var udfpsDisplayModeProvider: UdfpsDisplayModeProvider,
+        private val secureSettings: SecureSettings,
+        val requestId: Long,
+        @ShowReason val requestReason: Int,
+        private val controllerCallback: IUdfpsOverlayControllerCallback,
+        private val onTouch: (View, MotionEvent, Boolean) -> Boolean,
+        private val activityLaunchAnimator: ActivityLaunchAnimator,
+        private val featureFlags: FeatureFlags,
+        private val primaryBouncerInteractor: PrimaryBouncerInteractor,
+        private val alternateBouncerInteractor: AlternateBouncerInteractor,
+        private val isDebuggable: Boolean = Build.IS_DEBUGGABLE,
+) {
+    /** The view, when [isShowing], or null. */
+    var overlayView: UdfpsView? = null
+        private set
+
+    private var overlayParams: UdfpsOverlayParams = UdfpsOverlayParams()
+    private var sensorBounds: Rect = Rect()
+
+    private var overlayTouchListener: TouchExplorationStateChangeListener? = null
+
+    private val frameworkDimming = context.getResources().getBoolean(R.bool.config_udfpsFrameworkDimming)
+
+    private val coreLayoutParams = WindowManager.LayoutParams(
+        WindowManager.LayoutParams.TYPE_DISPLAY_OVERLAY,
+        0 /* flags set in computeLayoutParams() */,
+        PixelFormat.TRANSLUCENT
+    ).apply {
+        title = TAG
+        fitInsetsTypes = 0
+        gravity = android.view.Gravity.TOP or android.view.Gravity.LEFT
+        layoutInDisplayCutoutMode = WindowManager.LayoutParams.LAYOUT_IN_DISPLAY_CUTOUT_MODE_ALWAYS
+        flags = (Utils.FINGERPRINT_OVERLAY_LAYOUT_PARAM_FLAGS or
+                WindowManager.LayoutParams.FLAG_SPLIT_TOUCH)
+        if (frameworkDimming) {
+            flags = flags or WindowManager.LayoutParams.FLAG_DIM_BEHIND
+        }
+        privateFlags = WindowManager.LayoutParams.PRIVATE_FLAG_TRUSTED_OVERLAY
+        dimAmount = 0.0f
+
+        // Avoid announcing window title.
+        accessibilityTitle = " "
+
+        if (featureFlags.isEnabled(Flags.UDFPS_NEW_TOUCH_DETECTION)) {
+            inputFeatures = WindowManager.LayoutParams.INPUT_FEATURE_SPY
+        }
+    }
+
+    fun updateDimAmount(newDimAmount: Float) {
+        coreLayoutParams.dimAmount = newDimAmount
+        windowManager.updateViewLayout(overlayView, coreLayoutParams)
+    }
+
+    /** A helper if the [requestReason] was due to enrollment. */
+    val enrollHelper: UdfpsEnrollHelper? =
+        if (requestReason.isEnrollmentReason() && !shouldRemoveEnrollmentUi()) {
+            UdfpsEnrollHelper(context, fingerprintManager, secureSettings, requestReason)
+        } else {
+            null
+        }
+
+    /** If the overlay is currently showing. */
+    val isShowing: Boolean
+        get() = overlayView != null
+
+    /** Opposite of [isShowing]. */
+    val isHiding: Boolean
+        get() = overlayView == null
+
+    /** The animation controller if the overlay [isShowing]. */
+    val animationViewController: UdfpsAnimationViewController<*>?
+        get() = overlayView?.animationViewController
+
+    private var touchExplorationEnabled = false
+
+    private fun shouldRemoveEnrollmentUi(): Boolean {
+        if (isDebuggable) {
+            return Settings.Global.getInt(
+                context.contentResolver,
+                SETTING_REMOVE_ENROLLMENT_UI,
+                0 /* def */
+            ) != 0
+        }
+        return false
+    }
+
+    /** Show the overlay or return false and do nothing if it is already showing. */
+    @SuppressLint("ClickableViewAccessibility")
+    fun show(controller: UdfpsController, params: UdfpsOverlayParams): Boolean {
+        if (overlayView == null) {
+            overlayParams = params
+            sensorBounds = Rect(params.sensorBounds)
+            try {
+                overlayView = (inflater.inflate(
+                    R.layout.udfps_view, null, false
+                ) as UdfpsView).apply {
+                    overlayParams = params
+                    setUdfpsDisplayModeProvider(udfpsDisplayModeProvider)
+                    val animation = inflateUdfpsAnimation(this, controller)
+                    if (animation != null) {
+                        animation.init()
+                        animationViewController = animation
+                    }
+                    // This view overlaps the sensor area
+                    // prevent it from being selectable during a11y
+                    if (requestReason.isImportantForAccessibility()) {
+                        importantForAccessibility = View.IMPORTANT_FOR_ACCESSIBILITY_NO
+                    }
+
+                    windowManager.addView(this, coreLayoutParams.updateDimensions(animation))
+                    sensorRect = sensorBounds
+                    touchExplorationEnabled = accessibilityManager.isTouchExplorationEnabled
+                    overlayTouchListener = TouchExplorationStateChangeListener {
+                        if (accessibilityManager.isTouchExplorationEnabled) {
+                            setOnHoverListener { v, event -> onTouch(v, event, true) }
+                            setOnTouchListener(null)
+                            touchExplorationEnabled = true
+                        } else {
+                            setOnHoverListener(null)
+                            setOnTouchListener { v, event -> onTouch(v, event, true) }
+                            touchExplorationEnabled = false
+                        }
+                    }
+                    accessibilityManager.addTouchExplorationStateChangeListener(
+                        overlayTouchListener!!
+                    )
+                    overlayTouchListener?.onTouchExplorationStateChanged(true)
+                    useExpandedOverlay = featureFlags.isEnabled(Flags.UDFPS_NEW_TOUCH_DETECTION)
+                }
+            } catch (e: RuntimeException) {
+                Log.e(TAG, "showUdfpsOverlay | failed to add window", e)
+            }
+            return true
+        }
+
+        Log.v(TAG, "showUdfpsOverlay | the overlay is already showing")
+        return false
+    }
+
+    fun inflateUdfpsAnimation(
+        view: UdfpsView,
+        controller: UdfpsController
+    ): UdfpsAnimationViewController<*>? {
+        val isEnrollment = when (requestReason) {
+            REASON_ENROLL_FIND_SENSOR, REASON_ENROLL_ENROLLING -> true
+            else -> false
+        }
+
+        val filteredRequestReason = if (isEnrollment && shouldRemoveEnrollmentUi()) {
+            REASON_AUTH_OTHER
+        } else {
+            requestReason
+        }
+
+        return when (filteredRequestReason) {
+            REASON_ENROLL_FIND_SENSOR,
+            REASON_ENROLL_ENROLLING -> {
+                UdfpsEnrollViewController(
+                    view.addUdfpsView(R.layout.udfps_enroll_view) {
+                        updateSensorLocation(sensorBounds)
+                    },
+                    enrollHelper ?: throw IllegalStateException("no enrollment helper"),
+                    statusBarStateController,
+                    shadeExpansionStateManager,
+                    dialogManager,
+                    dumpManager,
+                    featureFlags,
+                    overlayParams.scaleFactor
+                )
+            }
+            REASON_AUTH_KEYGUARD -> {
+                UdfpsKeyguardViewController(
+                    view.addUdfpsView(R.layout.udfps_keyguard_view),
+                    statusBarStateController,
+                    shadeExpansionStateManager,
+                    statusBarKeyguardViewManager,
+                    keyguardUpdateMonitor,
+                    dumpManager,
+                    transitionController,
+                    configurationController,
+                    keyguardStateController,
+                    unlockedScreenOffAnimationController,
+                    dialogManager,
+                    controller,
+                    activityLaunchAnimator,
+                    featureFlags,
+                    primaryBouncerInteractor,
+                    alternateBouncerInteractor,
+                )
+            }
+            REASON_AUTH_BP -> {
+                // note: empty controller, currently shows no visual affordance
+                UdfpsBpViewController(
+                    view.addUdfpsView(R.layout.udfps_bp_view),
+                    statusBarStateController,
+                    shadeExpansionStateManager,
+                    dialogManager,
+                    dumpManager
+                )
+            }
+            REASON_AUTH_OTHER,
+            REASON_AUTH_SETTINGS -> {
+                UdfpsFpmOtherViewController(
+                    view.addUdfpsView(R.layout.udfps_fpm_other_view),
+                    statusBarStateController,
+                    shadeExpansionStateManager,
+                    dialogManager,
+                    dumpManager
+                )
+            }
+            else -> {
+                Log.e(TAG, "Animation for reason $requestReason not supported yet")
+                null
+            }
+        }
+    }
+
+    /** Hide the overlay or return false and do nothing if it is already hidden. */
+    fun hide(): Boolean {
+        val wasShowing = isShowing
+
+        overlayView?.apply {
+            if (isDisplayConfigured) {
+                unconfigureDisplay()
+            }
+            windowManager.removeView(this)
+            setOnTouchListener(null)
+            setOnHoverListener(null)
+            animationViewController = null
+            overlayTouchListener?.let {
+                accessibilityManager.removeTouchExplorationStateChangeListener(it)
+            }
+        }
+        overlayView = null
+        overlayTouchListener = null
+
+        return wasShowing
+    }
+
+    fun onEnrollmentProgress(remaining: Int) {
+        enrollHelper?.onEnrollmentProgress(remaining)
+    }
+
+    fun onAcquiredGood() {
+        enrollHelper?.animateIfLastStep()
+    }
+
+    fun onEnrollmentHelp() {
+        enrollHelper?.onEnrollmentHelp()
+    }
+
+    /**
+     * This function computes the angle of touch relative to the sensor and maps
+     * the angle to a list of help messages which are announced if accessibility is enabled.
+     *
+     */
+    fun onTouchOutsideOfSensorArea(
+        touchX: Float,
+        touchY: Float,
+        sensorX: Float,
+        sensorY: Float,
+        rotation: Int
+    ) {
+
+        if (!touchExplorationEnabled) {
+            return
+        }
+        val touchHints =
+            context.resources.getStringArray(R.array.udfps_accessibility_touch_hints)
+        if (touchHints.size != 4) {
+            Log.e(TAG, "expected exactly 4 touch hints, got $touchHints.size?")
+            return
+        }
+        val theStr = onTouchOutsideOfSensorAreaImpl(touchX, touchY, sensorX, sensorY, rotation)
+        Log.v(TAG, "Announcing touch outside : " + theStr)
+        animationViewController?.doAnnounceForAccessibility(theStr)
+    }
+
+    /**
+     * This function computes the angle of touch relative to the sensor and maps
+     * the angle to a list of help messages which are announced if accessibility is enabled.
+     *
+     * There are 4 quadrants of the circle (90 degree arcs)
+     *
+     * [315, 360] && [0, 45) -> touchHints[0] = "Move Fingerprint to the left"
+     * [45,  135)            -> touchHints[1] = "Move Fingerprint down"
+     * And so on.
+     */
+    fun onTouchOutsideOfSensorAreaImpl(
+        touchX: Float,
+        touchY: Float,
+        sensorX: Float,
+        sensorY: Float,
+        rotation: Int
+    ): String {
+        val touchHints =
+            context.resources.getStringArray(R.array.udfps_accessibility_touch_hints)
+
+        val xRelativeToSensor = touchX - sensorX
+        // Touch coordinates are with respect to the upper left corner, so reverse
+        // this calculation
+        val yRelativeToSensor = sensorY - touchY
+
+        var angleInRad =
+            Math.atan2(yRelativeToSensor.toDouble(), xRelativeToSensor.toDouble())
+        // If the radians are negative, that means we are counting clockwise.
+        // So we need to add 360 degrees
+        if (angleInRad < 0.0) {
+            angleInRad += 2.0 * Math.PI
+        }
+        // rad to deg conversion
+        val degrees = Math.toDegrees(angleInRad)
+
+        val degreesPerBucket = 360.0 / touchHints.size
+        val halfBucketDegrees = degreesPerBucket / 2.0
+        // The mapping should be as follows
+        // [315, 360] && [0, 45] -> 0
+        // [45, 135]             -> 1
+        var index = (((degrees + halfBucketDegrees) % 360) / degreesPerBucket).toInt()
+        index %= touchHints.size
+
+        // A rotation of 90 degrees corresponds to increasing the index by 1.
+        if (rotation == Surface.ROTATION_90) {
+            index = (index + 1) % touchHints.size
+        }
+
+        if (rotation == Surface.ROTATION_270) {
+            index = (index + 3) % touchHints.size
+        }
+
+        return touchHints[index]
+    }
+
+    /** Cancel this request. */
+    fun cancel() {
+        try {
+            controllerCallback.onUserCanceled()
+        } catch (e: RemoteException) {
+            Log.e(TAG, "Remote exception", e)
+        }
+    }
+
+    /** Checks if the id is relevant for this overlay. */
+    fun matchesRequestId(id: Long): Boolean = requestId == -1L || requestId == id
+
+    private fun WindowManager.LayoutParams.updateDimensions(
+        animation: UdfpsAnimationViewController<*>?
+    ): WindowManager.LayoutParams {
+        val paddingX = animation?.paddingX ?: 0
+        val paddingY = animation?.paddingY ?: 0
+        if (animation != null && animation.listenForTouchesOutsideView()) {
+            flags = flags or WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH
+        }
+
+        // Original sensorBounds assume portrait mode.
+        var rotatedBounds =
+            if (featureFlags.isEnabled(Flags.UDFPS_NEW_TOUCH_DETECTION)) {
+                Rect(overlayParams.overlayBounds)
+            } else {
+                Rect(overlayParams.sensorBounds)
+            }
+
+        val rot = overlayParams.rotation
+        if (rot == Surface.ROTATION_90 || rot == Surface.ROTATION_270) {
+            if (!shouldRotate(animation)) {
+                Log.v(
+                    TAG, "Skip rotating UDFPS bounds " + Surface.rotationToString(rot) +
+                            " animation=$animation" +
+                            " isGoingToSleep=${keyguardUpdateMonitor.isGoingToSleep}" +
+                            " isOccluded=${keyguardStateController.isOccluded}"
+                )
+            } else {
+                Log.v(TAG, "Rotate UDFPS bounds " + Surface.rotationToString(rot))
+                RotationUtils.rotateBounds(
+                    rotatedBounds,
+                    overlayParams.naturalDisplayWidth,
+                    overlayParams.naturalDisplayHeight,
+                    rot
+                )
+
+                if (featureFlags.isEnabled(Flags.UDFPS_NEW_TOUCH_DETECTION)) {
+                    RotationUtils.rotateBounds(
+                            sensorBounds,
+                            overlayParams.naturalDisplayWidth,
+                            overlayParams.naturalDisplayHeight,
+                            rot
+                    )
+                }
+            }
+        }
+
+        x = rotatedBounds.left - paddingX
+        y = rotatedBounds.top - paddingY
+        height = rotatedBounds.height() + 2 * paddingX
+        width = rotatedBounds.width() + 2 * paddingY
+
+        return this
+    }
+
+    private fun shouldRotate(animation: UdfpsAnimationViewController<*>?): Boolean {
+        if (animation !is UdfpsKeyguardViewController) {
+            // always rotate view if we're not on the keyguard
+            return true
+        }
+
+        // on the keyguard, make sure we don't rotate if we're going to sleep or not occluded
+        return !(keyguardUpdateMonitor.isGoingToSleep || !keyguardStateController.isOccluded)
+    }
+
+    private inline fun <reified T : View> UdfpsView.addUdfpsView(
+        @LayoutRes id: Int,
+        init: T.() -> Unit = {}
+    ): T {
+        val subView = inflater.inflate(id, null) as T
+        addView(subView)
+        subView.init()
+        return subView
+    }
+}
+
+@ShowReason
+private fun Int.isEnrollmentReason() =
+    this == REASON_ENROLL_FIND_SENSOR || this == REASON_ENROLL_ENROLLING
+
+@ShowReason
+private fun Int.isImportantForAccessibility() =
+    this == REASON_ENROLL_FIND_SENSOR ||
+            this == REASON_ENROLL_ENROLLING ||
+            this == REASON_AUTH_BP
diff --git a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsView.kt b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsView.kt
index 1e2e6c8b..e85e6f7b 100644
--- a/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsView.kt
+++ b/packages/SystemUI/src/com/android/systemui/biometrics/UdfpsView.kt
@@ -19,16 +19,24 @@ import android.content.Context
 import android.graphics.Canvas
 import android.graphics.Color
 import android.graphics.Paint
+import android.graphics.PixelFormat
 import android.graphics.PointF
 import android.graphics.Rect
 import android.graphics.RectF
+import android.os.FileObserver
 import android.util.AttributeSet
 import android.util.Log
 import android.view.MotionEvent
+import android.view.SurfaceHolder
+import android.view.SurfaceView
+import android.view.ViewGroup
 import android.view.Surface
 import android.widget.FrameLayout
 import com.android.systemui.R
 import com.android.systemui.doze.DozeReceiver
+import java.io.File
+
+import vendor.goodix.hardware.biometrics.fingerprint.V2_1.IGoodixFingerprintDaemon
 
 private const val TAG = "UdfpsView"
 
@@ -39,6 +47,54 @@ class UdfpsView(
     context: Context,
     attrs: AttributeSet?
 ) : FrameLayout(context, attrs), DozeReceiver {
+    private var currentOnIlluminatedRunnable: Runnable? = null
+    private val mySurfaceView = SurfaceView(context)
+    init {
+        mySurfaceView.setVisibility(INVISIBLE)
+        mySurfaceView.setZOrderOnTop(true)
+        addView(mySurfaceView, FrameLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT))
+        mySurfaceView.holder.addCallback(object: SurfaceHolder.Callback{
+            override fun surfaceCreated(p0: SurfaceHolder) {
+                Log.d("PHH", "Surface created!")
+                val paint = Paint(0 /* flags */);
+                paint.setAntiAlias(true);
+                paint.setStyle(Paint.Style.FILL);
+                val colorStr = android.os.SystemProperties.get("persist.sys.phh.fod_color", "00ff00");
+                try {
+                    val parsedColor = Color.parseColor("#" + colorStr);
+                    val r = (parsedColor shr 16) and 0xff;
+                    val g = (parsedColor shr  8) and 0xff;
+                    val b = (parsedColor shr  0) and 0xff;
+                    paint.setARGB(255, r, g, b);
+                } catch(t: Throwable) {
+                    Log.d("PHH", "Failed parsing color #" + colorStr, t);
+                }
+                var canvas: Canvas? = null
+                try {
+                    canvas = p0.lockCanvas();
+Log.d("PHH", "Surface dimensions ${canvas.getWidth()*1.0f} ${canvas.getHeight()*1.0f}")
+                    canvas.drawOval(RectF(0.0f, 0.0f, canvas.getWidth()*1.0f, canvas.getHeight()*1.0f), paint);
+                } finally {
+                    // Make sure the surface is never left in a bad state.
+                    if (canvas != null) {
+                        p0.unlockCanvasAndPost(canvas);
+                    }
+                }
+
+                currentOnIlluminatedRunnable?.run()
+            }
+
+            override fun surfaceChanged(p0: SurfaceHolder, p1: Int, p2: Int, p3: Int) {
+Log.d("PHH", "Got surface size $p1 $p2 $p3")
+            }
+
+            override fun surfaceDestroyed(p0: SurfaceHolder) {
+Log.d("PHH", "Surface destroyed!")
+            }
+        })
+        mySurfaceView.holder.setFormat(PixelFormat.RGBA_8888)
+
+    }
 
     // Use expanded overlay when feature flag is true, set by UdfpsViewController
     var useExpandedOverlay: Boolean = false
@@ -69,6 +125,8 @@ class UdfpsView(
     /** Parameters that affect the position and size of the overlay. */
     var overlayParams = UdfpsOverlayParams()
 
+    var dimUpdate: (Float) -> Unit = {}
+
     /** Debug message. */
     var debugMessage: String? = null
         set(value) {
@@ -153,6 +211,21 @@ class UdfpsView(
             !(animationViewController?.shouldPauseAuth() ?: false)
     }
 
+    fun goodixCmd(id: Int) {
+        val goodixSvc = IGoodixFingerprintDaemon.getService()
+        if(goodixSvc != null) {
+            goodixSvc.sendCommand(id, ArrayList(), { returnCode, resultData -> {
+                Log.e("PHH-Enroll", "Goodix send command returned code "+ returnCode);
+            }});
+        }
+    }
+
+    val asusGhbmOnAchieved = "/sys/class/drm/ghbm_on_achieved"
+    var hasAsusGhbm = File(asusGhbmOnAchieved).exists()
+    var samsungActualMaskBrightness = "/sys/class/lcd/panel/actual_mask_brightness"
+    val hasSamsungMask = File(samsungActualMaskBrightness).exists()
+    var fodFileObserver: FileObserver? = null
+
     fun configureDisplay(onDisplayConfigured: Runnable) {
         isDisplayConfigured = true
         animationViewController?.onDisplayConfiguring()
@@ -164,6 +237,26 @@ class UdfpsView(
         } else {
             doIlluminate(null /* surface */, onDisplayConfigured)
         }
+
+        mySurfaceView.setVisibility(VISIBLE)
+        Log.d("PHH", "setting surface visible!")
+
+        val brightness = File("/sys/class/backlight/panel0-backlight/brightness").readText().toDouble()
+        val maxBrightness = File("/sys/class/backlight/panel0-backlight/max_brightness").readText().toDouble()
+
+        // Assume HBM is max brightness
+        val dim = 1.0 - Math.pow( (brightness / maxBrightness), 1/2.3);
+        Log.d("PHH-Enroll", "Brightness is $brightness / $maxBrightness, setting dim to $dim")
+        if (hasAsusGhbm) {
+            dimUpdate(dim.toFloat())
+        }
+        if (hasSamsungMask) {
+            dimUpdate(dim.toFloat())
+        }
+
+        if(android.os.SystemProperties.get("ro.vendor.build.fingerprint").contains("ASUS")) {
+            goodixCmd(200001)
+        }
     }
 
     private fun doIlluminate(surface: Surface?, onDisplayConfigured: Runnable?) {
@@ -185,5 +278,49 @@ class UdfpsView(
             view.visibility = INVISIBLE
         }
         mUdfpsDisplayMode?.disable(null /* onDisabled */)
+
+        if (hasAsusGhbm) {
+            fodFileObserver = object: FileObserver(asusGhbmOnAchieved, FileObserver.MODIFY) {
+                override fun onEvent(event: Int, path: String): Unit {
+                    Log.d("PHH-Enroll", "Asus ghbm event")
+                    try {
+                        val spotOn = File(asusGhbmOnAchieved).readText().toInt()
+                        if(spotOn == 0) {
+                            dimUpdate(0.0f)
+                            fodFileObserver?.stopWatching()
+                            fodFileObserver = null
+                        }
+                    } catch(e: Exception) {
+                        Log.d("PHH-Enroll", "Failed dimpdate off", e)
+                    }
+                }
+            };
+            fodFileObserver?.startWatching();
+        } else if (hasSamsungMask) {
+            fodFileObserver = object: FileObserver(asusGhbmOnAchieved, FileObserver.MODIFY) {
+                override fun onEvent(event: Int, path: String): Unit {
+                    Log.d("PHH-Enroll", "samsung mask brightness event")
+                    try {
+                        val spotOn = File(samsungActualMaskBrightness).readText().toInt()
+                        if(spotOn == 0) {
+                            dimUpdate(0.0f)
+                            fodFileObserver?.stopWatching()
+                            fodFileObserver = null
+                        }
+                    } catch(e: Exception) {
+                        Log.d("PHH-Enroll", "Failed dimpdate off", e)
+                    }
+                }
+            };
+            fodFileObserver?.startWatching();
+        } else {
+            dimUpdate(0.0f)
+        }
+
+        mySurfaceView.setVisibility(INVISIBLE)
+        Log.d("PHH", "setting surface invisible!")
+        if(android.os.SystemProperties.get("ro.vendor.build.fingerprint").contains("ASUS")) {
+            goodixCmd(200003)
+        }
     }
 }
diff --git a/services/core/Android.bp b/services/core/Android.bp
index da704ee3..ab211cbb 100644
--- a/services/core/Android.bp
+++ b/services/core/Android.bp
@@ -177,7 +177,12 @@ java_library_static {
         "overlayable_policy_aidl-java",
         "SurfaceFlingerProperties",
         "com.android.sysprop.watchdog",
-        "vendor.samsung.hardware.sysinput-V1.2-java", // HIDL
+        // HIDL
+        "vendor.samsung.hardware.sysinput-V1.2-java",
+        "vendor.goodix.hardware.biometrics.fingerprint-V2.1-java",
+        "vendor.samsung.hardware.biometrics.fingerprint-V3.0-java",
+        "vendor.oplus.hardware.biometrics.fingerprint-V2.1-java",
+        "vendor.oppo.hardware.biometrics.fingerprint-V2.1-java",
         "faceunlock_framework",
         "kotlin-stdlib",
         "kotlinx_coroutines_android",
diff --git a/services/core/java/com/android/server/biometrics/AuthService.java b/services/core/java/com/android/server/biometrics/AuthService.java
index a94c4c07..b7d010a3 100644
--- a/services/core/java/com/android/server/biometrics/AuthService.java
+++ b/services/core/java/com/android/server/biometrics/AuthService.java
@@ -77,6 +77,22 @@ import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
+import android.hardware.display.DisplayManager;
+
+import android.graphics.Point;
+import android.util.DisplayMetrics;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileReader;
+import java.io.PrintWriter;
+
+import android.os.FileObserver;
+import android.os.Build;
+
+import vendor.samsung.hardware.biometrics.fingerprint.V3_0.ISehBiometricsFingerprint;
+import vendor.goodix.hardware.biometrics.fingerprint.V2_1.IGoodixFingerprintDaemon;
+import vendor.samsung.hardware.sysinput.V1_0.ISehSysInputDev;
+
 /**
  * System service that provides an interface for authenticating with biometrics and
  * PIN/pattern/password to BiometricPrompt and lock screen.
@@ -95,6 +111,9 @@ public class AuthService extends SystemService {
     @VisibleForTesting
     final IAuthService.Stub mImpl;
 
+    private FileObserver fodFileObserver = null;
+    private ISehBiometricsFingerprint mSamsungFingerprint = null;
+
     /**
      * Class for injecting dependencies into AuthService.
      * TODO(b/141025588): Replace with a dependency injection framework (e.g. Guice, Dagger).
@@ -652,6 +671,72 @@ public class AuthService extends SystemService {
         registerAuthenticators(hidlConfigs);
 
         mInjector.publishBinderService(this, mImpl);
+        try {
+            mSamsungFingerprint = ISehBiometricsFingerprint.getService();
+            android.util.Log.e("PHH", "Got samsung fingerprint HAL");
+        } catch(Exception e) {
+            android.util.Log.e("PHH", "Failed getting Samsung fingerprint HAL", e);
+        }
+        if(samsungHasCmd("fod_enable") && mSamsungFingerprint != null) {
+            samsungCmd("fod_enable,1,1,0");
+            String actualMaskBrightnessPath = "/sys/class/lcd/panel/actual_mask_brightness";
+            android.util.Log.e("PHH-Enroll", "Reading actual brightness file gives " + readFile(actualMaskBrightnessPath));
+            fodFileObserver = new FileObserver(actualMaskBrightnessPath, FileObserver.MODIFY) {
+                @Override
+                public void onEvent(int event, String path) {
+                    String actualMask = readFile(actualMaskBrightnessPath);
+                    try {
+                        mSamsungFingerprint = ISehBiometricsFingerprint.getService();
+                    } catch(Exception e) {}
+                    Slog.d("PHH-Enroll", "New actual mask brightness is " + actualMask);
+                    try {
+                        int eventReq = 0;
+                        if("0".equals(actualMask)) {
+                            eventReq = 1; //released
+                        } else {
+                            eventReq = 2; //pressed
+                        }
+                        if(mSamsungFingerprint != null) {
+                            mSamsungFingerprint.sehRequest(22 /* SEM_FINGER_STATE */, eventReq, new java.util.ArrayList<Byte>(),
+                                    (int retval, java.util.ArrayList<Byte> out) -> {} );
+                        }
+                    } catch(Exception e) {
+                        Slog.d("PHH-Enroll", "Failed setting samsung event for mask observer", e);
+                    }
+                }
+            };
+            fodFileObserver.startWatching();
+        }
+
+        String asusGhbmOnAchieved = "/sys/class/drm/ghbm_on_achieved";
+        if( (new File(asusGhbmOnAchieved)).exists()) {
+            fodFileObserver = new FileObserver(asusGhbmOnAchieved, FileObserver.MODIFY) {
+                boolean wasOn = false;
+                @Override
+                public void onEvent(int event, String path) {
+                    String spotOn = readFile(asusGhbmOnAchieved);
+                    if("1".equals(spotOn)) {
+                        if(!wasOn) {
+                            try {
+                                IGoodixFingerprintDaemon goodixDaemon = IGoodixFingerprintDaemon.getService();
+
+                                //Send UI ready
+                                goodixDaemon.sendCommand(200002, new java.util.ArrayList<Byte>(), (returnCode, resultData) -> {
+                                    Slog.e(TAG, "Goodix send command touch pressed returned code "+ returnCode);
+                                });
+                            } catch(Throwable t) {
+                                Slog.d("PHH-Enroll", "Failed sending goodix command", t);
+                            }
+                        }
+                        wasOn = true;
+                    } else {
+                        wasOn = false;
+                    }
+                }
+            };
+            fodFileObserver.startWatching();
+        }
+
     }
 
     /**
@@ -775,18 +860,104 @@ public class AuthService extends SystemService {
                 ? modality : (modality & ~BiometricAuthenticator.TYPE_CREDENTIAL);
     }
 
+    private int[] dynamicUdfpsProps() {
+        DisplayManager mDM = (DisplayManager) getContext().getSystemService(Context.DISPLAY_SERVICE);
+        Point displayRealSize = new Point();
+        DisplayMetrics displayMetrics = new DisplayMetrics();
+        mDM.getDisplay(0).getRealSize(displayRealSize);
+        mDM.getDisplay(0).getMetrics(displayMetrics);
+
+        if(readFile("/sys/class/fingerprint/fingerprint/position") != null) {
+            try {
+            ISehSysInputDev s = ISehSysInputDev.getService();
+            s.getTspFodInformation(0, (a, b) -> {
+                Slog.d("PHH-Enroll", "TspFod info " + a + ", " + b);
+            });
+            s.getTspFodPosition(0, (a, b) -> {
+                Slog.d("PHH-Enroll", "TspFod info " + a + ", " + b);
+            });
+            }catch(Throwable t) {
+                Slog.d("PHH-Enroll", "heya ", t);
+            }
+
+
+            android.util.Log.d("PHH", "Samsung fingerprint");
+            String[] fodPositionArray = readFile("/sys/class/fingerprint/fingerprint/position").split(",");
+            float bottomMM = Float.parseFloat(fodPositionArray[0]);
+            float areaSizeMM = Float.parseFloat(fodPositionArray[5]);
+            float heightMM = Float.parseFloat(fodPositionArray[2]);
+            float bottomInch = bottomMM * 0.0393700787f;
+            float areaSizeInch = areaSizeMM * 0.0393700787f;
+            float heightInch = heightMM * 0.0393700787f;
+            int bottomPx = (int)(bottomInch * displayMetrics.ydpi);
+            int areaSizePx = (int)(areaSizeInch * displayMetrics.ydpi);
+            int midDistPx = (int)(areaSizeInch * displayMetrics.ydpi / 2.0f);
+
+            float mW = areaSizePx/2;
+            float mH = areaSizePx/2;
+            float mX = displayRealSize.x/2;
+            //float mY = displayRealSize.y - bottomPx - midDistPx;
+            float mY = displayRealSize.y - (bottomInch * displayMetrics.ydpi) - (areaSizeInch * displayMetrics.ydpi / 2.0f);
+
+            samsungCmd(String.format("fod_rect,%d,%d,%d,%d", (int)(mX - mW/2), (int)(mY - mW/2), (int)(mX + mW/2), (int)(mY + mW/2)));
+            Slog.d("PHH-Enroll", "Display real size is " + displayRealSize.y + ", dpy " + displayMetrics.ydpi);
+
+            int udfpsProps[] = new int[3];
+            udfpsProps[0] = (int)mX;
+            udfpsProps[1] = (int)mY;
+            udfpsProps[2] = (int)mW;
+
+            try {
+                mSamsungFingerprint = ISehBiometricsFingerprint.getService();
+                Slog.d("PHH-Enroll", "Samsung ask for sensor status");
+                mSamsungFingerprint.sehRequest(6, 0, new java.util.ArrayList(), (int retval, java.util.ArrayList<Byte> out) -> {
+                    Slog.d("PHH-Enroll", "Result is " + retval);
+                    for(int i=0; i<out.size(); i++) {
+                        Slog.d("PHH-Enroll", "\t" + i + ":" + out.get(i));
+                    }
+                } );
+                Slog.d("PHH-Enroll", "Samsung ask for sensor brightness value");
+                mSamsungFingerprint.sehRequest(32, 0, new java.util.ArrayList(), (int retval, java.util.ArrayList<Byte> out) -> {
+                    Slog.d("PHH-Enroll", "Result is " + retval);
+                    for(int i=0; i<out.size(); i++) {
+                        Slog.d("PHH-Enroll", "\t" + i + ":" + out.get(i));
+                    }
+                } );
+
+            } catch(Exception e) {
+                Slog.d("PHH-Enroll", "Failed setting samsung3.0 fingerprint recognition", e);
+            }
+            return udfpsProps;
+        }
+
+        if(android.os.SystemProperties.get("ro.vendor.build.fingerprint").contains("ASUS_I006D")) {
+            int udfpsProps[] = new int[3];
+            udfpsProps[0] = displayRealSize.x/2;
+            udfpsProps[1] = 1741;
+            udfpsProps[2] = 110;
+            return udfpsProps;
+        }
+
+        return new int[0];
+    }
 
     private FingerprintSensorPropertiesInternal getHidlFingerprintSensorProps(int sensorId,
             @BiometricManager.Authenticators.Types int strength) {
         // The existence of config_udfps_sensor_props indicates that the sensor is UDFPS.
-        final int[] udfpsProps = getContext().getResources().getIntArray(
+        int[] udfpsProps = getContext().getResources().getIntArray(
                 com.android.internal.R.array.config_udfps_sensor_props);
 
         // Non-empty workaroundLocations indicates that the sensor is SFPS.
         final List<SensorLocationInternal> workaroundLocations =
                 getWorkaroundSensorProps(getContext());
 
-        final boolean isUdfps = !ArrayUtils.isEmpty(udfpsProps);
+        boolean isUdfps = !ArrayUtils.isEmpty(udfpsProps);
+        if(!isUdfps) udfpsProps = dynamicUdfpsProps();
+        isUdfps = !ArrayUtils.isEmpty(udfpsProps);
+
+        if(udfpsProps.length > 0) {
+            Slog.d("PHH-Enroll", "Got udfps infos " + udfpsProps[0] + ", " + udfpsProps[1] + ", " + udfpsProps[2]);
+        }
 
         // config_is_powerbutton_fps indicates whether device has a power button fingerprint sensor.
         final boolean isPowerbuttonFps = getContext().getResources().getBoolean(
@@ -843,6 +1014,69 @@ public class AuthService extends SystemService {
                 supportsSelfIllumination, resetLockoutRequiresChallenge);
     }
 
+    private static boolean samsungHasCmd(String cmd) {
+        try {
+            File f = new File("/sys/devices/virtual/sec/tsp/cmd_list");
+            if(!f.exists()) return false;
+
+            android.util.Log.d("PHH", "Managed to grab cmd list, checking...");
+            BufferedReader b = new BufferedReader(new FileReader(f));
+            String line = null;
+            while( (line = b.readLine()) != null) {
+                if(line.equals(cmd)) return true;
+            }
+            android.util.Log.d("PHH", "... nope");
+            return false;
+        } catch(Exception e) {
+            android.util.Log.d("PHH", "Failed reading cmd_list", e);
+            return false;
+        }
+    }
+
+    public static void samsungCmd(String cmd) {
+        try {
+            writeFile("/sys/devices/virtual/sec/tsp/cmd", cmd);
+
+            String status = readFile("/sys/devices/virtual/sec/tsp/cmd_status");
+            String ret = readFile("/sys/devices/virtual/sec/tsp/cmd_result");
+
+            android.util.Log.d("PHH", "Sending command " + cmd + " returned " + ret + ":" + status);
+        } catch(Exception e) {
+            android.util.Log.d("PHH", "Failed sending command " + cmd, e);
+        }
+    }
+
+    private static void writeFile(String path, String value) {
+        try {
+            PrintWriter writer = new PrintWriter(path, "UTF-8");
+            writer.println(value);
+            writer.close();
+        } catch(Exception e) {
+            android.util.Log.d("PHH", "Failed writing to " + path + ": " + value);
+        }
+    }
+
+    private static void writeFile(File file, String value) {
+        try {
+            PrintWriter writer = new PrintWriter(file, "UTF-8");
+            writer.println(value);
+            writer.close();
+        } catch(Exception e) {
+            android.util.Log.d("PHH", "Failed writing to " + file + ": " + value);
+        }
+    }
+
+    private static String readFile(String path) {
+        try {
+            File f = new File(path);
+
+            BufferedReader b = new BufferedReader(new FileReader(f));
+            return b.readLine();
+        } catch(Exception e) {
+            return null;
+        }
+    }
+
     private SensorPropertiesInternal getHidlIrisSensorProps(int sensorId,
             @BiometricManager.Authenticators.Types int strength) {
         final int maxEnrollmentsPerUser = 1;
-- 
2.25.1

